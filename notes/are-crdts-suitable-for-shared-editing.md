https://blog.kevinjahns.de/are-crdts-suitable-for-shared-editing

好的，我们来详细讲解一下您提供的这份文档。

这份文档 INTERNALS2.md（其内容与 Yjs 官方的 INTERNALS.md 一致）和附带的博文《CRDT 适合用于共享编辑吗？》都深入探讨了 Yjs 的内部工作原理、性能优化及其在现实世界中的适用性。

我将结合这两份材料，为您提供一个全面的讲解。

### 核心思想：万物皆列表 (List CRDT)

这是 Yjs 设计的基石。为了能用一套统一的冲突解决算法处理所有协同数据类型，Yjs 将所有数据结构都抽象成一个**有序列表**。

- **数组 (Arrays)**：天然就是列表，直接映射。
- **文本 (Text)**：被看作是字符的列表。
- **哈希表 (Maps)**：被看作是键值对（`[key, value]`）的列表。当多个用户修改同一个 `key` 时，采用“**最后写入者获胜**”的策略，即只有最新插入的那个键值对生效，所有旧的键值对都会被标记为已删除。

### 关键优化：复合表示法 (Compound Representation)

传统 CRDT 的一个主要性能瓶颈是为**每个字符**都分配一个唯一的 ID 和元数据，这导致了巨大的内存开销。Yjs 通过一个关键优化解决了这个问题：

**它不为一个字符创建一个对象，而是将连续的插入操作合并成一个 `Item` 对象。**

- **示例 1：** 当用户输入 "Hello" 时，一个朴素的 CRDT 会创建 5 个对象，每个对象代表一个字符。而 Yjs 会将这 5 个字符合并成一个 `Item`，其内容为 `'Hello'`。
- **示例 2：** 当用户粘贴一大段文本时，无论文本多长，Yjs 都只会创建一个 `Item`。

这个优化带来的好处是革命性的：**元数据的数量不再与文档的字符数成正比，而是与用户的编辑操作次数成正比。** 这极大地降低了内存占用和对象创建的开销，使得 Yjs 在处理大型文档时依然高效。

### 冲突解决：`origin` 和 `originRight`

当两个或多个用户在**完全相同的位置**同时插入内容时，就会发生并发冲突。Yjs 需要一个确定性的规则来决定这些插入内容的最终顺序，以保证所有客户端的文档状态最终一致。

Yjs 的 `Item` 对象有两个关键属性来处理这个问题：

- `origin`: 指向该 `Item` 插入时其左侧 `Item` 的 ID。
- `originRight`: 指向该 `Item` 插入时其右侧 `Item` 的 ID。

当冲突发生时，Yjs 的 `integrate()` 方法会遵循 YATA 论文中定义的算法来排序。简化的规则是：如果两个 `Item` 的 `origin` 相同，那么就比较它们的 `clientID`，`clientID` 较大的用户插入的内容会排在后面。这确保了无论操作到达的顺序如何，最终的排序结果总是一致的。

### 性能与现实考量

博文《CRDT 适合用于共享编辑吗？》有力地回应了关于 CRDT 性能开销的质疑，并用翔实的基准测试数据证明了 Yjs 的高效性。

1.  **内存占用可控**：通过“复合表示法”优化，即使是包含数百万次编辑历史的超大文档，Yjs 的内存占用也完全在可接受的范围内。一个包含 2600 万次操作（1800 万次插入，800 万次删除）的文档，内存占用仅为 220MB。
2.  **解析速度快**：文档的解析时间与操作次数呈**线性关系**，而非指数关系。这意味着文档越大，解析时间会相应增加，但不会出现性能雪崩。解析一个有 26 万次编辑历史的论文级文档仅需 20 毫秒。
3.  **编码效率高**：Yjs 会将文档状态编码成非常紧凑的二进制格式，这使得网络传输和持久化存储的开销很小。

**结论是：** 对于人类的编辑行为而言，几乎不可能创建一个 Yjs 无法处理的文档。Yjs 所带来的微小性能开销，与它提供的强大的去中心化、离线可用、任意网络拓扑同步等能力相比，是完全值得的。
